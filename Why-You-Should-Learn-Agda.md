# Why You should Learn Agda

Agda is a powerful, dependently typed functional programming language and proof assistant with interactive editing and a large selection of powerful language features. It lets us to express constraints and proofs directly in the types of our definitions, and abstract over basically anything, allowing for extremely powerful metaprogramming capabilities. Such a language is a playground in which we can formalize whatever we would like, be it imperative algorithms, logical systems, or abstract mathematics, and learning one is an amazing experience.

## Why Agda

Though any modern proof-assistant would have sufficed, I chose Agda for its purity, simplicity and beauty, for its interactive editing, and for its well-polished set of modern features. Agda is the place to be if you want to do fancy things with types. Additionally, when you know one dependently typed language, it's very easy to learn another as most of the core concepts are the same, and Agda in particular is ideal for learning these core concepts.

## For Programmers

When we reason about the correctness of our programs, we are doing nothing less than theorem proving in our head, regardless of whether or not we are aware of it. As we structure our programs into small maintainable parts, we are subconsciously trying to organize the logic of our program into the precise form which we hope to be most conducive to being able to effectively prove things about individual parts, and ultimately compile the many small proofs into larger proofs about larger chunks of the overall functionality of the program. When our code doesn't work, it is often precisely because we missed a proof, or couldn't quite compile all the smaller proofs together correctly. For this reason, knowing what it is like to *formally prove* things about your code and hard-code invariants into your types, held accountable to them by the type system, is extremely valuable and interesting to any programmer. For this task I cannot recommend more to learn a proof assistant, such as Agda, Lean, Idris, Coq, F*, etc. as it is a fascinating and fruitful experience.

## For Functional Programmers

If you like (or are curious about) functional programming, or perhaps are interested in programming languages, this course will cover everything up to many of the most advanced topics in functional programming (often including mathematical proofs and formalizations of them), as well as get to know some incredibly powerful type-system features. Learning Agda will also give you a huge advantage when learning languages in the ML programming language family, and will make it much easier to understand what are often considered to be very advanced topics or language features. Agda is particularly similar to Haskell, and other than a few trivial syntactical differences between the two languages, the first 10 chapters of this tutorial cover all of the central topics found in a typical Haskell tutorial, and should leave the reader competent in functional programming, should they have interest in using it in the future.

## For Agda Users

If you are reading this despite already knowing Agda (or another proof assistant), I have left a series of bonus challenge exercises at the end of each chapter. These exercises are designed to be fun challenges, regardless of how much Agda you know. Though depending on your level of experience, plenty of the normal exercises may also be entertaining and informative, and you can just skip anything that is too easy or uninteresting.

## For Mathematicians

First of all, as mentioned under "For Agda Users", I have filled this entire course with many interesting challenge exercises, so if you love hard and interesting problems then you will enjoy trying to crack these exercises. Other than that, type theory and Agda are an amazing way to dive into the world of formal mathematics and mathematical foundations. Understanding how to properly formalize ideas and theorems is incredibly satisfying, and may even change the way you understand math. The ability to go and try to formalize whatever the hell you want is really awesome, and can be really fun (and its also really nice to be able to scratch that itch of not feeling like you really understand some concept or proof). Proof assistants are also slowly growing popularity in the modern world of mathematics (mathlib, written in Lean, is a great example of this), and have been used to verify some very technical, tricky proofs. As an added bonus, languages like Agda present programming and computation in a form which is undoubtedly more beautiful than what you have ever seen before, in a way that parallels the beauty of various mathematics, which any math lover will surely enjoy.

## For Logicians

Agda is a proof-assistant based in type theory, an alternative to set theory, and gives a computational interpretation of logic and math. It presents its take on what it means for something to be true or false, what it means to define a theorem, and what it means to write a proof, and is an amazing starting point into the world of logic. This tutorial will cover and formalize various logical axioms, and explore their consequences, and how they might imply or interact with each other. These include axioms of classical logic, such as various forms of double negation elimination, the law of excluded middle, Pierces law (aka callCC), and the axiom of choice, as well as weaker axioms like the Kudora Principle and Markov's principle. Additionally we will look at parametricity, function extensionality, various forms of quotienting, and even the a bit of Homotopy Type Theory and the univalence axiom. Finally, to finish off this course with a bang, we will formalize some basic logical systems with computational interpretations, building up to a minimal programming language/proof assistant which constructively interprets peano arithmetic.
